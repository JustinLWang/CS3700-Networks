### High-Level Approach
My program begins by accepting command line arguments using the argparser module in Python. it would then default the port to 27993 and retrieve the required hostname and neu_id from the command line. After this, the socket would be created. My program then checks if the "-s" argument was given, and if so, it changes the default port to 27994 and wraps the original socket to a encrypted TLS socket. Next I check if the specified port argument was given, and if so, I set the port to the given argument. I then connect the socket to the server and send the hello message. After recieving the start message, I store the game id into a variable. Now is the time that I begin guessing. All of the guessing is done through a function called guessStrategy. Once that function recieves a "bye" message, I print the flag. If it recieves a "error", I print that message. If it recieves an invalid message from the server, then the program is terminated. If it received a "retry", then I continue guessing. Once the program ends, I close the socket

### Challenges
The main challenge was actually figuring out how to make everything run on the autograder. I was not familiar with "./" commands and shebangs. Additionally, converting everything to UNIX was a struggle for me, as the autograder couldn't interpret window-style line breaks.

### Guess Strategy
As stated before, all of my guessing is done in a function called guessStrategy. Within this function, the first thing it does it creates 3 arrays: "not_in_word", "wrong_position" "right_position". These three arrays will hold information about the current game and determine if a word is to be "guessed"/sent to the server or not. "not_in_word" stores letters that are not in the "secret word". "wrong_position" holds letters that are in the letter, but were in the wrong position when guessed. "right_position" holds letters that were guessed in the right position. After the 3 arrays are created, a nested function called shouldIGuess is implemented. This function loops through all the characters in a "guess" and returns False if that character is: in "not_in_word" and not in "wrong_position" and not in "right_position". It returns true otherwise. After this another nested function called readMarks is implemented. This function takes the server message retrieved after making a guess, and reads the marks of the word. If there is a 2, it adds that letter to "right position". If there is a 1, it adds that letter to "wrong_position". If there is a 0, it adds it to "not_in_word." After these two helper functions are defined, we then loop through each word in the "word_list". For each word, we call shouldIGuess. If it returns False, then we skip to the next word. If it returns True, then we send the guess to the server. Then we read the message from the server. If the server returns a "rety" message, then we call readMarks and add the information to the three arrays, and move on to the next word. If the server returns a "bye" message, then we print the flag and exist the program. If the server returns a "error" message, then we print the error and exit the program. If the server returns a invalid type of message, then we print that there was an invalid message from the server, and then terminate the entire program

### Testing
The main way of testing and debugging this program was adding individual print statements to each method. This allowed me to ensure that each smaller component of the project worked  perfectly before I ran the entire program. These print statements included, which guess I was on, what words I was guessing, the current game information (3 arrays), etc... Additionally, I tested my program on the command line with all different combinations of arguments: including specifying the port -p, including and not including -s, giving an incorrect hostname and neuid, not including the required arguments (host, neuid), etc...